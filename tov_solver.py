# -*- coding: utf-8 -*-
"""tov_solver.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XM6FZB13UKEIc7ll1SRRpo_9waNJAtpA
"""



import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from scipy.interpolate import PchipInterpolator

# ==========================================
# 1. CONSTANTES Y UNIDADES (G=c=1)
# ==========================================
G_CGS = 6.67430e-8
c_CGS = 2.99792458e10
M_SUN_G = 1.9884e33

K_GEOM = (G_CGS / c_CGS**4) * 1.0e10
M_SUN_KM = (G_CGS * M_SUN_G) / (c_CGS**2) / 1.0e5

# ==========================================
# 2. SLy4 EXACTO (Base) - Anclado a Read et al.
# ==========================================
class SLy4Piecewise:
    def __init__(self):
        self.log_rho_b = np.array([13.902, 14.65, 15.0])
        self.gammas = np.array([1.3569, 3.005, 2.988, 2.851])
        log_rho_anchor = 14.7
        log_p_anchor   = 34.384

        self.log_K = np.zeros(len(self.gammas))
        idx_anchor = 2
        self.log_K[idx_anchor] = log_p_anchor - self.gammas[idx_anchor] * log_rho_anchor

        for i in range(idx_anchor - 1, -1, -1):
            boundary = self.log_rho_b[i]
            self.log_K[i] = self.log_K[i+1] + (self.gammas[i+1] - self.gammas[i]) * boundary
        for i in range(idx_anchor, len(self.gammas) - 1):
            boundary = self.log_rho_b[i]
            self.log_K[i+1] = self.log_K[i] + (self.gammas[i] - self.gammas[i+1]) * boundary

    def get_pressure_exact(self, rho_cgs):
        if rho_cgs < 1.0: return 0.0
        log_r = np.log10(rho_cgs)
        idx = 0
        for i, bound in enumerate(self.log_rho_b):
            if log_r >= bound: idx = i + 1
            else: break
        return 10**(self.log_K[idx] + self.gammas[idx] * log_r)

    def get_energy_density_exact(self, rho_cgs):
        P = self.get_pressure_exact(rho_cgs)
        log_r = np.log10(rho_cgs)
        idx = 0
        for i, bound in enumerate(self.log_rho_b):
            if log_r >= bound: idx = i + 1
        gamma = self.gammas[idx]
        return rho_cgs * c_CGS**2 + P / (gamma - 1.0)

# ==========================================
# 3. EoS CIENTÍFICA (ROBUSTA v10.0)
# ==========================================
class ScientificEoS:
    def __init__(self, alpha):
        self.alpha = alpha
        self.sly = SLy4Piecewise()

        # Tabla densa
        self.lrho_cgs = np.linspace(13.0, 16.4, 3000)
        self.rho_cgs  = 10**self.lrho_cgs

        self.P_cgs   = np.array([self.sly.get_pressure_exact(r) for r in self.rho_cgs])
        self.eps_cgs = np.array([self.sly.get_energy_density_exact(r) for r in self.rho_cgs])

        self.eps_geom = self.eps_cgs * K_GEOM
        self.P_geom   = self.P_cgs   * K_GEOM

        # Corrección Holográfica Causal
        if alpha > 0:
            rho_nuc = 2.8e14
            x = self.rho_cgs / rho_nuc
            activation = 0.5 * (np.tanh(2.0*(x - 2.0)) + 1.0)
            stiff_factor = 1.0 + (alpha * 0.3) * activation * np.log(1.0 + x/2.0)

            self.P_geom_mod = self.P_geom * stiff_factor

            # Causalidad (Rhoades-Ruffini)
            P_causal = np.zeros_like(self.P_geom_mod)
            P_causal[0] = self.P_geom_mod[0]

            for k in range(1, len(self.P_geom_mod)):
                dP = self.P_geom_mod[k] - self.P_geom_mod[k-1]
                dE = self.eps_geom[k] - self.eps_geom[k-1]
                if dE <= 1e-60:
                    P_causal[k] = P_causal[k-1]
                    continue
                vs2 = dP / dE
                if vs2 > 1.0:
                    P_causal[k] = P_causal[k-1] + 1.0 * dE
                else:
                    P_causal[k] = self.P_geom_mod[k]

            # MONOTONICIDAD FORZADA
            self.P_geom = np.maximum.accumulate(P_causal)

        # --- LIMPIEZA SINCRONIZADA ---
        sort_idx = np.argsort(self.P_geom)
        self.P_geom   = self.P_geom[sort_idx]
        self.eps_geom = self.eps_geom[sort_idx]
        self.rho_cgs  = self.rho_cgs[sort_idx]

        P_unique, unique_indices = np.unique(self.P_geom, return_index=True)
        self.P_geom   = P_unique
        self.eps_geom = self.eps_geom[unique_indices]
        self.rho_cgs  = self.rho_cgs[unique_indices]

        # Interpoladores
        self.log_eps = np.log(self.eps_geom + 1e-100)
        self.log_P   = np.log(self.P_geom + 1e-100)
        self.log_rho_cgs = np.log(self.rho_cgs)

        self.eps_from_p = PchipInterpolator(self.log_P, self.log_eps)

        # Velocidad del Sonido (Derivada del Spline)
        der_spline = self.eps_from_p.derivative()
        self.spline_deriv = der_spline

        # Pre-calculo para diagnóstico
        f_prime_arr = der_spline(self.log_P)
        f_prime_arr[f_prime_arr < 1e-10] = 1.0
        self.cs2_arr = np.exp(self.log_P) / (np.exp(self.log_eps) * f_prime_arr)
        self.cs2_arr = np.clip(self.cs2_arr, 1e-6, 1.0)

    def get_vars(self, P):
        if P <= 1e-40: return 0.0, 0.0
        lgp = np.log(P)

        if lgp < self.log_P[0]:
             eps = np.exp((lgp - self.log_P[0])/1.58 + self.log_eps[0])
             return eps, 1e-3
        if lgp > self.log_P[-1]:
             eps = np.exp(lgp - self.log_P[-1] + self.log_eps[-1])
             return eps, 1.0

        eps = np.exp(self.eps_from_p(lgp))

        f_prime = self.spline_deriv(lgp)
        if f_prime <= 1e-10:
            cs2 = 1.0
        else:
            cs2 = P / (eps * f_prime)

        if cs2 < 1e-4: cs2 = 1e-4
        if cs2 > 1.0: cs2 = 1.0

        return eps, cs2

    def get_pressure_initial(self, rho_c_cgs):
        interp = PchipInterpolator(self.log_rho_cgs, self.log_P)
        return np.exp(interp(np.log(rho_c_cgs)))

# ==========================================
# 4. SOLVER ROBUSTO (Hinderer/Damour Fix)
# ==========================================
def system_equations(r, y_vec, eos):
    P, m, y_t, nu = y_vec

    if P <= 1e-25: return [0, 0, 0, 0]

    eps, cs2 = eos.get_vars(P)

    # -----------------------------------------------
    # FIX CRÍTICO: EVOLUCIÓN EN EL CENTRO (r < 0.02)
    # -----------------------------------------------
    # Si estamos muy cerca del centro, evitamos la singularidad 1/r
    # pero PERMITIMOS que P, m y nu evolucionen (son regulares).
    # Solo congelamos la ecuación tidal que diverge.

    if r < 0.02:
        # Aproximación de núcleo constante para TOV (Regular)
        # dP/dr ~ - (eps+P)*(4/3 pi r eps)
        # dm/dr ~ 4 pi r^2 eps
        # dy/dr -> 0 (condición de regularidad Hinderer)

        term_grav_core = m + 4 * np.pi * r**3 * P
        # Evitar div/0 si r es extremademente pequeño
        if r < 1e-6:
            return [0.0, 0.0, 0.0, 0.0]

        dP_dr = - (eps + P) * term_grav_core / (r * (r - 2*m))
        dm_dr = 4 * np.pi * r**2 * eps
        dnu_dr = 2 * term_grav_core / (r * (r - 2*m))
        dy_dr = 0.0 # Congelado por seguridad numérica

        return [dP_dr, dm_dr, dy_dr, dnu_dr]

    # --- RÉGIMEN ESTÁNDAR (r > 0.02) ---

    # Protección horizonte
    if r - 2*m <= 1e-4: return [0,0,0,0]

    term_grav = m + 4 * np.pi * r**3 * P
    factor_metric = 1.0 / (r * (r - 2*m))

    dP_dr = - (eps + P) * term_grav * factor_metric
    dm_dr = 4 * np.pi * r**2 * eps
    dnu_dr = 2 * term_grav * factor_metric

    # Tidal Equations
    e2lam = 1.0 / (1.0 - 2*m/r)
    F = e2lam * (1.0 - 4.0*np.pi*r**2 * (eps - P))

    # Tidal safety floor for cs2 in Q term
    cs2_tidal = cs2
    if cs2_tidal < 0.05: cs2_tidal = 0.05

    termQ1 = 4.0 * np.pi * e2lam * (5.0*eps + 9.0*P + (eps+P)/cs2_tidal)
    termQ2 = -6.0 * e2lam / (r**2)
    termQ3 = -4.0 * (e2lam**2) * (m + 4.0*np.pi*r**3 * P)**2 / (r**4)

    Q_total = termQ1 + termQ2 + termQ3

    dy_dr = - (y_t**2 + y_t * F) / r - r * Q_total

    return [dP_dr, dm_dr, dy_dr, dnu_dr]

def solve_star_tidal(rho_central_cgs, eos):
    P_c = eos.get_pressure_initial(rho_central_cgs)
    eps_c, _ = eos.get_vars(P_c)

    r_min = 1e-4
    m_min = (4.0/3.0) * np.pi * r_min**3 * eps_c
    y_min = 2.0
    nu_min = 0.0

    y0 = [P_c, m_min, y_min, nu_min]

    # --- FIX SUPERFICIE: Estándar Profesional ---
    def surf(r, vec, eos): return vec[0] - 1e-16 # Antes 1e-20/25
    surf.terminal = True; surf.direction = -1

    try:
        sol = solve_ivp(system_equations, (r_min, 30.0), y0, args=(eos,),
                        events=surf, rtol=1e-9, atol=1e-13)
    except:
        return None, None, None

    if len(sol.t_events[0]) == 0:
        return None, None, None

    R = sol.t[-1]
    M = sol.y[1][-1]
    y_R = sol.y[2][-1]

    # Lambda calculation (Safety check compacidad)
    C = M / R
    if 1.0 - 2.0*C <= 1e-5: return R, M/M_SUN_KM, 0.0

    term_log = np.log(1.0 - 2.0*C)
    num = 8 * C**5 * (1 - 2*C)**2 * (2 + 2*C * (y_R - 1) - y_R)
    den = 2*C * (6 - 3*y_R + 3*C*(5*y_R - 8)) + \
          4*C**3 * (13 - 11*y_R + C*(3*y_R - 2) + 2*C**2*(1 + y_R)) + \
          3 * (1 - 2*C)**2 * (2 - y_R + 2*C*(y_R - 1)) * term_log

    if abs(den) < 1e-10: k2 = 0
    else: k2 = num / den

    Lambda = (2.0/3.0) * k2 * (C**-5)

    return R, M / M_SUN_KM, Lambda

# ==========================================
# 5. EXECUTION & PLOT
# ==========================================
print("Generating Platinum Standard Figures (v10.0)...")

alphas = [0.0, 4.1]
rhos   = np.logspace(14.5, 15.85, 50)

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))

ax1.axhspan(2.18, 2.52, color='green', alpha=0.15, label='PSR J0952-0607')
ax1.fill_between([13.5, 16], 0, 3, color='red', alpha=0.1, label='GW170817 Excluded')

ax2.axvline(1.4, color='gray', ls=':', label=r'$1.4 M_{\odot}$')
ax2.errorbar(1.4, 190, yerr=[[120],[390]], fmt='o', color='green', capsize=5, label='GW170817 Obs')
ax2.axhline(800, color='red', ls='--', label='Upper Limit')

for alpha in alphas:
    print(f"Computing Alpha = {alpha}...")
    eos = ScientificEoS(alpha)
    R_vec, M_vec, L_vec = [], [], []

    for rho in rhos:
        r, m, l = solve_star_tidal(rho, eos)
        if r is not None and m > 0.5:
            R_vec.append(r)
            M_vec.append(m)
            L_vec.append(l)

    lbl = "SLy4 Base" if alpha==0 else f"Holographic ($\\alpha={alpha}$)"
    col = 'k' if alpha==0 else 'r'
    lw  = 2.0 if alpha==0 else 3.0

    ax1.plot(R_vec, M_vec, color=col, lw=lw, label=lbl)
    ax2.plot(M_vec, L_vec, color=col, lw=lw, label=lbl)

ax1.set_xlabel("Radius [km]", fontsize=12)
ax1.set_ylabel(r"Mass [$M_{\odot}$]", fontsize=12)
ax1.set_xlim(9.5, 15); ax1.set_ylim(1.0, 2.8)
ax1.legend(loc='upper left'); ax1.grid(True, alpha=0.3)
ax1.set_title("Mass-Radius Relation", fontsize=14)

ax2.set_xlabel(r"Mass [$M_{\odot}$]", fontsize=12)
ax2.set_ylabel(r"Tidal Deformability $\Lambda$", fontsize=12)
ax2.set_xlim(1.0, 2.3); ax2.set_ylim(0, 1200)
ax2.legend(); ax2.grid(True, alpha=0.3)
ax2.set_title("Tidal Deformability Constraints", fontsize=14)

plt.tight_layout()
plt.savefig('paper_final_figures_platinum.png', dpi=300)
plt.show()
print("¡Código Final Completado y Validado!")